# Let binding - simple

let x = 5

==>

Script(LetBinding(let,LetValueBinding(VariableDefinition,"=",Number)))

# Let binding - expression

let y = x + 1

==>

Script(LetBinding(let,LetValueBinding(VariableDefinition,"=",BinaryExpression(VariableName,ArithOp,Number))))

# Let with type annotation

let name: string = "John"

==>

Script(LetBinding(let,LetValueBinding(VariableDefinition,":",TypeName,"=",String)))

# Function expression

let add = (a, b) => a + b

==>

Script(LetBinding(let,LetValueBinding(VariableDefinition,"=",ArrowFunction(ParamList("(",ParamItems(UnlabeledParameter(SimpleParameter(VariableName)),",",SimpleParameter(VariableName)),")"),"=>",BinaryExpression(VariableName,ArithOp,VariableName)))))

# Unit-parameter function

let noop = () => 1

==>

Script(LetBinding(let,LetValueBinding(VariableDefinition,"=",ArrowFunction(UnitToken,"=>",Number))))

# Boolean literals

let isTrue = true
let isFalse = false

==>

Script(LetBinding(let,LetValueBinding(VariableDefinition,"=",BooleanLiteral)),LetBinding(let,LetValueBinding(VariableDefinition,"=",BooleanLiteral)))

# Array expression

let numbers = [1, 2, 3]

==>

Script(LetBinding(let,LetValueBinding(VariableDefinition,"=",ArrayExpression("[",Number,",",Number,",",Number,"]"))))

# Record expression

let point = {x: 1, y: 2}

==>

Script(LetBinding(let,LetValueBinding(VariableDefinition,"=",RecordExpression("{",Property(PropertyDefinition,":",Number),",",Property(PropertyDefinition,":",Number),"}"))))

# Function call

log("Hello")

==>

Script(CallExpression(VariableName,"(",Argument(String),")"))

# Member expression

Stdlib.Option.map

==>

Script(MemberExpression(ModulePrefix,MemberLeaf(VariableName)))

# Nested member expression - simple

let bar = foo.bar

==>

Script(LetBinding(let,LetValueBinding(VariableDefinition,"=",MemberExpression(RecordFieldAccess(VariableName,".",PropertyName)))))

# Nested member expression - module chain

let bar = foo.Utils.Foo.bar

==>

Script(LetBinding(let,LetValueBinding(VariableDefinition,"=",MemberExpression(RecordFieldAccess(VariableName,".",ModulePrefix,PropertyName)))))

# Bracket property access

let bar = foo["bar"]

==>

Script(LetBinding(let,LetValueBinding(VariableDefinition,"=",MemberExpression(VariableName,"[",String,"]"))))

# Parenthesized expression

let result = (x + y) * z

==>

Script(LetBinding(let,LetValueBinding(VariableDefinition,"=",BinaryExpression(ParenthesizedExpression("(",BinaryExpression(VariableName,ArithOp,VariableName),")"),ArithOp,VariableName))))

# String literal

let greeting = "Hello, World!"

==>

Script(LetBinding(let,LetValueBinding(VariableDefinition,"=",String)))

# Multiline string

let multiline = "Hello
World"

==>

Script(LetBinding(let,LetValueBinding(VariableDefinition,"=",String)))

# Number literal

let pi = 3.14
let hex = 0xFF
let binary = 0b1010

==>

Script(LetBinding(let,LetValueBinding(VariableDefinition,"=",Number)),LetBinding(let,LetValueBinding(VariableDefinition,"=",Number)),LetBinding(let,LetValueBinding(VariableDefinition,"=",Number)))

# Unary expressions

let neg = -5
let not = !true

==>

Script(LetBinding(let,LetValueBinding(VariableDefinition,"=",UnaryExpression(ArithOp,Number))),LetBinding(let,LetValueBinding(VariableDefinition,"=",UnaryExpression(LogicOp,BooleanLiteral))))

# Binary expressions

let sum = a + b
let product = a * b
let comparison = a < b

==>

Script(LetBinding(let,LetValueBinding(VariableDefinition,"=",BinaryExpression(VariableName,ArithOp,VariableName))),LetBinding(let,LetValueBinding(VariableDefinition,"=",BinaryExpression(VariableName,ArithOp,VariableName))),LetBinding(let,LetValueBinding(VariableDefinition,"=",BinaryExpression(VariableName,CompareOp,VariableName))))

# Exotic variable name

let \"ðŸš€" = "bar"

==>

Script(LetBinding(let,LetValueBinding(VariableDefinition,"=",String)))

# RegExp literals

let matcher = /\w+/g
let escaped = /a\/b/i

==>

Script(LetBinding(let,LetValueBinding(VariableDefinition,"=",RegExpLiteral)),LetBinding(let,LetValueBinding(VariableDefinition,"=",RegExpLiteral)))

# Annotations and extensions

@react.component
@@heavy
@as("foo")
%client.call(value)
%%client.call(value)

==>

Script(Decorator("@",AttributeIdentifier),Decorator("@@",AttributeIdentifier),Decorator("@",AttributeIdentifier,AttributeArguments("(",String,")")),ExtensionExpression("%",AttributeIdentifier,AttributeArguments("(",VariableName,")")),ExtensionExpression("%%",AttributeIdentifier,AttributeArguments("(",VariableName,")")))
