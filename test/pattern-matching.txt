# Simple switch with number patterns

switch x {
| 1 => "one"
| 2 => "two"
| _ => "other"
}

==>

Script(SwitchExpression(switch,VariableName,SwitchCase(Pattern(Number),String),SwitchCase(Pattern(Number),String),SwitchCase(Pattern(VariableName),String)))

# Switch with constructor patterns

switch option {
| Some(value) => value
| None => 0
}

==>

Script(SwitchExpression(switch,VariableName,SwitchCase(Pattern(ConstructorPattern(ConstructorName,Pattern(VariableName))),VariableName),SwitchCase(Pattern(ConstructorPattern(ConstructorName)),Number)))

# Switch with string patterns

switch color {
| "red" => 1
| "blue" => 2
| "green" => 3
}

==>

Script(SwitchExpression(switch,VariableName,SwitchCase(Pattern(String),Number),SwitchCase(Pattern(String),Number),SwitchCase(Pattern(String),Number)))

# Switch with array patterns

switch arr {
| [] => "empty"
| [x] => x
| [x, y] => x + y
}

==>

Script(SwitchExpression(switch,VariableName,SwitchCase(Pattern(ArrayPattern),String),SwitchCase(Pattern(ArrayPattern(Pattern(VariableName))),VariableName),SwitchCase(Pattern(ArrayPattern(Pattern(VariableName),Pattern(VariableName))),BinaryExpression(VariableName,ArithOp,VariableName))))

# Switch with record patterns

switch point {
| {x: 0, y: 0} => "origin"
| {x, y} => "point"
}

==>

Script(SwitchExpression(switch,VariableName,SwitchCase(Pattern(RecordPattern(PatternField(PropertyName,Pattern(Number)),PatternField(PropertyName,Pattern(Number)))),String),SwitchCase(Pattern(RecordPattern(PatternField(PropertyName),PatternField(PropertyName))),String)))

# Switch with nested patterns

switch result {
| Ok(Some(value)) => value
| Ok(None) => 0
| Error(_) => -1
}

==>

Script(SwitchExpression(switch,VariableName,SwitchCase(Pattern(ConstructorPattern(ConstructorName,Pattern(ConstructorPattern(ConstructorName,Pattern(VariableName))))),VariableName),SwitchCase(Pattern(ConstructorPattern(ConstructorName,Pattern(ConstructorPattern(ConstructorName)))),Number),SwitchCase(Pattern(ConstructorPattern(ConstructorName,Pattern(VariableName))),UnaryExpression(ArithOp,Number))))

# Switch in expression context

let result = switch x {
| 1 => "one"
| _ => "other"
}

==>

Script(LetBinding(let,VariableDefinition,SwitchExpression(switch,VariableName,SwitchCase(Pattern(Number),String),SwitchCase(Pattern(VariableName),String))))

# Switch with boolean patterns

switch flag {
| true => 1
| false => 0
}

==>

Script(SwitchExpression(switch,VariableName,SwitchCase(Pattern(BooleanLiteral),Number),SwitchCase(Pattern(BooleanLiteral),Number)))

# Pattern with guard clause

switch x {
| n when n > 0 => "positive"
| n when n < 0 => "negative"
| _ => "zero"
}

==>

Script(SwitchExpression(switch,VariableName,SwitchCase(Pattern(VariableName),PatternGuard(when,BinaryExpression(VariableName,CompareOp,Number)),String),SwitchCase(Pattern(VariableName),PatternGuard(when,BinaryExpression(VariableName,CompareOp,Number)),String),SwitchCase(Pattern(VariableName),String)))

# Pattern with complex guard

switch value {
| Some(x) when x > 10 && x < 100 => "valid"
| _ => "invalid"
}

==>

Script(SwitchExpression(switch,VariableName,SwitchCase(Pattern(ConstructorPattern(ConstructorName,Pattern(VariableName))),PatternGuard(when,BinaryExpression(BinaryExpression(VariableName,CompareOp,Number),LogicOp,BinaryExpression(VariableName,CompareOp,Number))),String),SwitchCase(Pattern(VariableName),String)))

# Pattern with function call guard

switch item {
| x when isValid(x) => process(x)
| _ => skip()
}

==>

Script(SwitchExpression(switch,VariableName,SwitchCase(Pattern(VariableName),PatternGuard(when,CallExpression(VariableName,VariableName)),CallExpression(VariableName,VariableName)),SwitchCase(Pattern(VariableName),CallExpression(VariableName))))
