import { styleTags, tags as t } from "@lezer/highlight";

export const rescriptHighlight = styleTags({
  "let type external exception": t.definitionKeyword,
  "if else switch when while for in to downto try catch": t.controlKeyword,
  "module open include": t.moduleKeyword,
  "true false": t.bool,
  "private rec mutable": t.typeOperator,
  await: t.operatorKeyword,

  Script: t.meta,
  Statement: t.meta,
  statement: t.meta,
  blockItem: t.meta,

  ModuleDeclaration: t.namespace,
  ModuleDeclarationBody: t.namespace,
  ModuleTypeDeclaration: t.namespace,
  ModuleTypeModuleSpec: t.namespace,
  ModuleExpression: t.namespace,
  ModuleBody: t.meta,
  ModulePackExpression: t.namespace,
  ModulePackContent: t.namespace,
  ModuleTypeExpr: t.typeName,
  ModuleTypeBody: t.typeName,
  ModuleTypeStatement: t.typeName,
  ModuleSpec: t.meta,
  ModuleWithConstraint: t.meta,
  ModulePath: t.namespace,
  ModulePrefix: t.namespace,
  ModuleName: t.namespace,
  ModuleUnpackBinding: t.definition(t.variableName),

  OpenStatement: t.moduleKeyword,
  IncludeStatement: t.moduleKeyword,
  ExternalDeclaration: t.meta,

  LetBinding: t.definitionKeyword,
  LetValueBinding: t.definition(t.variableName),
  ValueSpec: t.definition(t.variableName),

  TypeDeclaration: t.definition(t.typeName),
  TypeBinding: t.definition(t.typeName),
  TypeSpec: t.definition(t.typeName),
  TypeAlias: t.typeName,
  TypeBody: t.typeName,
  TypeApplication: t.typeName,
  TypeParams: t.typeName,
  TypeParam: t.typeName,
  TypeParameter: t.typeName,
  TypeAngleLeftNode: t.angleBracket,
  TypeAngleRightNode: t.angleBracket,
  FunctionType: t.typeName,
  FunctionArrow: t.operator,
  ParenthesizedType: t.paren,

  RecordType: t.typeName,
  RecordTypeField: t.propertyName,

  VariantType: t.typeName,
  VariantConstructorCase: t.atom,
  VariantConstructor: t.atom,
  VariantSpreadCase: t.operator,
  VariantConstructorArgs: t.meta,
  VariantConstructorResult: t.meta,

  PolyVariantType: t.typeName,
  PolyVariantCaseList: t.typeName,
  PolyVariantCase: t.typeName,
  PolyVariantTagCase: t.atom,
  PolyVariantSpreadCase: t.operator,
  PolyVariantTypeReference: t.typeName,
  PolyVariantVarianceMarker: t.operator,
  PolyVariantTag: t.atom,
  PolyVariantPayload: t.meta,

  Pattern: t.meta,
  PatternPrimary: t.meta,
  PatternAlias: t.meta,
  PatternArguments: t.meta,
  PatternField: t.propertyName,
  PatternGuard: t.controlKeyword,
  VariantSpreadPattern: t.operator,
  PolyVariantPattern: t.atom,
  PolyVariantSpreadPattern: t.operator,
  ArrayPattern: t.meta,
  ListPattern: t.meta,
  RecordPattern: t.meta,
  UnitPattern: t.atom,
  ParenthesizedPattern: t.paren,

  SwitchExpression: t.meta,
  SwitchCase: t.meta,
  IfExpression: t.meta,
  ElseClause: t.meta,
  WhileExpression: t.meta,
  ForExpression: t.meta,
  ForDirection: t.meta,
  TryExpression: t.meta,
  BlockExpression: t.meta,

  ArrowFunction: t.function,
  CallExpression: t.function,
  MemberExpression: t.meta,
  MemberLeaf: t.propertyName,
  BinaryExpression: t.operator,
  UnaryExpression: t.operator,
  ParenthesizedExpression: t.paren,
  Decorator: t.annotation,
  ExtensionExpression: t.annotation,
  UnitLiteral: t.atom,

  ArrayExpression: t.meta,
  ListExpression: t.meta,
  DictExpression: t.meta,
  RecordExpression: t.meta,
  Property: t.propertyName,
  PropertyDefinition: t.propertyName,
  PropertyName: t.propertyName,

  Argument: t.meta,
  LabeledArgument: t.meta,
  ArgumentValue: t.meta,

  ParamList: t.meta,
  DotUncurried: t.operator,
  ParamItems: t.meta,
  SingleAnnotatedParameter: t.meta,
  LabeledParameterList: t.meta,
  UnlabeledParameter: t.meta,
  parameter: t.meta,
  LabeledParameter: t.labelName,
  SimpleParameter: t.meta,
  ParameterAnnotation: t.typeName,
  ParameterDefault: t.meta,

  Quote: t.string,
  Hash: t.operator,

  VariableName: t.variableName,
  VariableDefinition: t.definition(t.variableName),
  TypeName: t.typeName,
  ConstructorName: t.atom,
  LabelName: t.labelName,

  Number: t.number,
  String: t.string,
  TemplateString: t.string,
  TemplateContent: t.special(t.string),
  Char: t.character,
  Escape: t.escape,
  ArithOp: t.arithmeticOperator,
  LogicOp: t.logicOperator,
  CompareOp: t.compareOperator,
  StringOp: t.operator,
  PipeOp: t.operator,
  "( )": t.paren,
  "[ ]": t.squareBracket,
  "{ }": t.brace,
  ". , : ;": t.separator,
  "=> =": t.definitionOperator,
  "~ ?": t.modifier,
  "|": t.separator,
  _: t.keyword,
  LineComment: t.lineComment,
  BlockComment: t.blockComment,

  JSXElement: t.content,
  "JSXStartTag JSXEndTag JSXSelfCloseEndTag JSXStartCloseTag": t.angleBracket,
  JSXIdentifier: t.tagName,
  JSXMemberExpression: t.tagName,
  JSXAttribute: t.attributeName,
  JSXAttributeValue: t.attributeValue,
  JSXExpressionContainer: t.content,
  JSXText: t.content,
});
