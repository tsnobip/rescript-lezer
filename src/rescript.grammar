@precedence {
  member,
  call,
  prefix,
  times @left,
  plus @left,
  concat @left,
  pipe @left,
  rel @left,
  and @left,
  or @left,
  arrow @right,
  statement @cut
}

@top Script { statement* }

@top SingleExpression { expression }

statement[@isGroup=Statement] {
  LetBinding |
  ModuleDeclaration |
  ModuleTypeDeclaration |
  TypeDeclaration |
  expression
}

ModuleTypeDeclaration {
  kw<"module"> kw<"type"> ConstructorName "=" ModuleTypeBody
}

ModuleTypeBody {
  "{" (TypeDeclaration | LetBinding)* "}"
}

ModuleDeclaration {
  kw<"module"> ConstructorName (":" typeConstraint)? "=" ModuleBody
}

ModuleBody {
  "{" statement* "}"
}

typeConstraint {
  typePath (typeConstraintClause)*
}

typeConstraintClause {
  kw<"with"> kw<"type"> typePath "=" type
}

typePath {
  identifier ("." identifier)*
}

TypeDeclaration {
  kw<"type"> (kw<"rec">)? TypeDefinition typeParams? "=" typeDefinition
}

typeParams {
  "<" commaSep<typeParam> ">"
}

typeParam {
  Wildcard { "_" } |
  TypeParam { "'" identifier }
}

typeDefinition {
  type |
  VariantDeclaration { "|"? VariantConstructor ("|" VariantConstructor)* }
}

VariantConstructor[@dynamicPrecedence=1] {
  ConstructorName (VariantConstructorArgs)? (":" type)?
}

VariantConstructorArgs {
  "(" commaSep<type> ")"
}

LetBinding {
  kw<"let"> (kw<"rec">)? (ModuleUnpack | VariableDefinition) parameterList? (":" type)? "=" expression
}

ModuleUnpack {
  kw<"module"> "(" ConstructorName ")"
}

parameterList {
  "(" commaSep<parameter> ")"
}

parameter {
  LabeledParameter |
  OptionalParameter |
  VariableName
}

LabeledParameter {
  "~" VariableName ("=" expression)?
}

OptionalParameter {
  "~" VariableName "=" "?"
}

SwitchExpression[@dynamicPrecedence=1] {
  kw<"switch"> expression "{" SwitchCase* "}"
}

SwitchCase[@dynamicPrecedence=2] {
  "|" Pattern (PatternGuard)? "=>" expression
}

PatternGuard {
  kw<"when"> guardExpression
}

guardExpression {
  CallExpression { guardExpression !call "(" commaSep<expression> ")" } |
  MemberExpression { guardExpression !member "." (PropertyName | ConstructorName) } |
  BinaryExpression {
    guardExpression !times (ArithOp<"*"> | ArithOp<"/"> | kw<"mod">) guardExpression |
    guardExpression !plus (ArithOp<"+"> | ArithOp<"-">) guardExpression |
    guardExpression !rel (LessThan | CompareOp<"<=" | ">" | ">=" | "==" | "!=">) guardExpression |
    guardExpression !and LogicOp<"&&"> guardExpression |
    guardExpression !or LogicOp<"||"> guardExpression
  } |
  UnaryExpression { !prefix (ArithOp<"-"> | LogicOp<"!">) guardExpression } |
  ParenthesizedExpression { "(" expression ")" } |
  Number |
  String |
  boolean |
  VariableName |
  ConstructorName
}

Pattern {
  Wildcard { "_" } |
  VariableName |
  Number |
  String |
  boolean |
  ConstructorPattern |
  ArrayPattern |
  RecordPattern |
  ParenthesizedPattern
}

ConstructorPattern {
  ConstructorName ("(" commaSep<Pattern> ")")?
}

ArrayPattern {
  "[" commaSep<Pattern> "]"
}

RecordPattern {
  "{" commaSep<PatternField> "}"
}

PatternField {
  PropertyName (":" Pattern)?
}

ParenthesizedPattern {
  "(" Pattern ")"
}

expression[@isGroup=Expression] {
  Number |
  String |
  TemplateString |
  Char |
  boolean |
  VariableName |
  ConstructorName |
  ArrayExpression { "[" commaSep<expression> "]" } |
  ListExpression { kw<"list"> "{" commaSep<expression> "}" } |
  DictExpression { kw<"dict"> "{" commaSep<DictEntry> "}" } |
  RecordExpression { "{" commaSep<Property | statement> "}" } |
  Decorator { "@" VariableName } |
  ExtensionExpression { "%" VariableName "(" commaSep<expression> ")" } |
  FirstClassModule { kw<"module"> "(" expression (":" typeConstraint)? ")" } |
  SwitchExpression |
  ArrowFunction[@dynamicPrecedence=1] {
    !arrow (
      VariableName |
      LabeledParam |
      ParamList
    ) "=>" expression
  } |
  CallExpression { expression !call "(" commaSep<expression> ")" } |
  MemberExpression { expression !member "." (PropertyName | ConstructorName) } |
  BinaryExpression {
    expression !times (ArithOp<"*"> | ArithOp<"/"> | kw<"mod">) expression |
    expression !plus (ArithOp<"+"> | ArithOp<"-">) expression |
    expression !concat StringOp<"++"> expression |
    expression !pipe PipeOp<"->" | "|>"> expression |
    expression !rel (LessThan | CompareOp<"<=" | ">" | ">=" | "==" | "!=">) expression |
    expression !and LogicOp<"&&"> expression |
    expression !or LogicOp<"||"> expression
  } |
  UnaryExpression { !prefix (ArithOp<"-"> | LogicOp<"!">) expression } |
  ParenthesizedExpression { "(" expression ")" } |
  JSXElement
}

LabeledParam {
  "~" VariableName
}

DictEntry {
  String ":" expression
}

Property {
  PropertyDefinition ":" expression
}

ParamList {
  "(" commaSep<parameter> ")"
}

type[@isGroup=Type] {
  TypeName |
  PolyVariantType { "[" PolyVariantBound commaSep<VariantTag> "]" (typeConstraintAs)? } |
  FunctionType[@dynamicPrecedence=1] { !arrow type Arrow type } |
  ParameterizedType { TypeName TypeArgList } |
  ParenthesizedType { "(" type ")" }
}

TypeArgList {
  LessThan commaSep<type> GreaterThan
}

PolyVariantBound {
  GreaterThan | LessThan
}

VariantTag {
  "#" ConstructorName
}

typeConstraintAs {
  kw<"as"> TypeParam
}

TypeParam { "'" identifier }

commaSep<content> {
  "" | content ("," content?)*
}

commaSep1<content> {
  content ("," content)*
}

// Keywords
kw<term> { @specialize[@name={term}]<identifier, term> }

boolean { @specialize[@name=BooleanLiteral]<identifier, "true" | "false"> }

VariableName { identifier }
VariableDefinition { identifier }
TypeName { identifier }
TypeDefinition { identifier }
ConstructorName { uppercaseIdentifier }
PropertyName { identifier }
PropertyDefinition { identifier }

@skip { spaces | newline | LineComment | BlockComment }

@context trackNewline from "./tokens.js"

@skip {} {
  String[isolate] {
    '"' (stringContentDouble | Escape)* ('"' | "\n")
  }
  
  TemplateString[isolate] {
    "`" (TemplateContent | Interpolation)* "`"
  }
  
  BlockComment[isolate] { "/*" (blockCommentContent | blockCommentNewline)* blockCommentEnd }
}

TemplateContent {
  templateText
}

Interpolation {
  "${" expression "}"
}

@local tokens {
  blockCommentEnd { "*/" }
  blockCommentNewline { "\n" }
  @else blockCommentContent
}

@tokens {
  spaces[@export] { $[\u0009 \u000b\u00a0\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]+ }
  newline[@export] { $[\r\n\u2028\u2029] }

  LineComment[isolate] { "//" ![\n]* }

  identifierChar { @asciiLetter | $[_$] }
  
  identifier { $[a-z_] (identifierChar | @digit)* }
  
  uppercaseIdentifier { $[A-Z] (identifierChar | @digit)* }

  @precedence { spaces, newline, identifier, "_" }

  Number {
    (@digit ("_" | @digit)* ("." ("_" | @digit)*)? | "." @digit ("_" | @digit)*)
      (("e" | "E") ("+" | "-")? ("_" | @digit)+)? |
    @digit ("_" | @digit)* "n" |
    "0x" $[0-9a-fA-F_]+ |
    "0b" $[01_]+ |
    "0o" $[0-7_]+
  }

  @precedence { Number, "." }

  Char { "'" (![\\\n'] | "\\" _) "'" }

  Escape {
    "\\" ("x" $[0-9a-fA-F] $[0-9a-fA-F] | "u" ("{" $[0-9a-fA-F]+ "}" | $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F] $[0-9a-fA-F]) | ![xu])
  }

  stringContentDouble { ![\\\n"]+ }

  ArithOp<expr> { expr }
  LogicOp<expr> { expr }
  CompareOp<expr> { expr }
  StringOp<expr> { expr }
  PipeOp<expr> { expr }
  
  templateText { ![\`$]+ | "$" ![\{] }

  @precedence { LineComment, ArithOp }

  "=>"
  "("  ")" "[" "]" "{" "}"
  "." "," ":" ";"
  "=" "?" "|" "~" "'" "@" "%" "_" "`" "${" "#"

  Arrow { "=>" }

  JSXEndTag { ">" }
  JSXSelfCloseEndTag { "/>" }
  JSXStartCloseTag { "</" }
  JSXText { ![<{]+ }
  JSXIdentifier { identifier }
}

@skip {} {
  JSXElement {
    JSXSelfClosingTag |
    JSXOpenTag jsxChildren* JSXCloseTag
  }
}

jsxChildren {
  JSXText |
  JSXElement |
  JSXExpressionContainer
}

JSXExpressionContainer {
  "{" expression "}"
}

JSXSelfClosingTag { JSXStartTag jsxElementName jsxAttribute* JSXSelfCloseEndTag }
JSXOpenTag { JSXStartTag jsxElementName jsxAttribute* JSXEndTag }
JSXCloseTag { JSXStartCloseTag jsxElementName? JSXEndTag }

jsxElementName {
  JSXIdentifier |
  JSXMemberExpression
}

JSXMemberExpression { (JSXMemberExpression | JSXIdentifier) "." JSXIdentifier }

jsxAttribute {
  JSXAttribute { JSXIdentifier ("=" jsxAttributeValue)? }
}

jsxAttributeValue {
  String |
  "{" expression "}"
}

@external propSource rescriptHighlight from "./highlight"

@external tokens insertSemicolon from "./tokens" { insertSemi }

@external tokens jsx from "./tokens" { JSXStartTag, LessThan, GreaterThan }

@detectDelim
