### Repo context

This repository provides a ReScript grammar for the Lezer parser generator. The core artifact is a generated parser (src/parser.js) created by running the lezer generator on the grammar at `src/rescript.grammar`. The package is bundled into `dist/` with Rollup and tests exercise the generated parser against the `test/*.txt` cases.

### Primary workflows (what to run)

- Build the parser and bundle:
  - npm run build — runs `lezer-generator src/rescript.grammar -o src/parser && rollup -c` (see `package.json`).
  - For debug-friendly names use: npm run build-debug.
- Run tests:
  - npm test — runs `mocha test/test-*.js`, tests import the generated parser from `dist/index.js` (see `test/test-rescript.js`).

### What to edit vs what to regenerate

- Edit `src/rescript.grammar` to change the grammar rules. The grammar references helpers in `src/tokens.js` and `src/highlight.js`:
  - `@external tokens insertSemicolon from "./tokens" { insertSemi }` — see `src/tokens.js` for the external tokenizer.
  - `@external propSource rescriptHighlight from "./highlight"` — highlighting mapping lives in `src/highlight.js`.
- After modifying `src/rescript.grammar` run `npm run build` to regenerate `src/parser.js` and produce the `dist/` bundle.

### Key files to know

- `src/rescript.grammar` — the full Lezer grammar. Entry points: `@top Script` and `@top SingleExpression`.
- `src/tokens.js` — handwritten ExternalTokenizer implementations (newline tracking, JSX vs `<` disambiguation, semicolon insertion). Changes here affect tokenization decisions that the grammar relies on.
- `src/highlight.js` — maps grammar node names to Lezer highlight tags.
- `rollup.config.js` — how the package is bundled to `dist/index.js` and `dist/index.cjs`.
- `test/*.txt` and `test/test-rescript.js` — corpus of source snippets and the test runner that validates the generated parser.

### Patterns and project-specific conventions

- Grammar-first workflow: canonical source is `src/rescript.grammar`. Generated parser code in `src/parser.js` and `dist/` should be treated as build artifacts.
- Tokenization quirks are implemented in `src/tokens.js`. When fixing parse ambiguity (e.g., JSX vs comparison) prefer adding small, targeted external tokenizers rather than making the grammar significantly more permissive.
- The grammar uses `@context trackNewline from "./tokens.js"` to allow semicolon insertion based on newline context. Maintain that contract if refactoring token logic.
- Tests rely on `@lezer/generator/dist/test` helpers to convert `test/*.txt` into mocha test cases. Keep test files in plain `.txt` and follow the pattern in existing tests.

### Examples to copy/paste

- Re-generate parser (from repo root):

  npm run build

- Run the test suite:

  npm test

- Example: when adding a new token that depends on surrounding whitespace, add an ExternalTokenizer in `src/tokens.js` and wire it into the grammar with `@external tokens` (example: `insertSemicolon` and `jsx` in the current grammar).

### Quick debugging tips

- If tests fail after grammar changes, run `npm run build-debug` to produce named productions (easier to read generated parser output).
- To inspect generated parser source open `src/parser.js` (temporary, regenerated) or `dist/index.js` (bundled output).

### Troubleshooting generator errors

- The `lezer-generator` can fail with shift/reduce or reduce/reduce conflicts after grammar edits. When that happens:
  - Run `npm run build-debug` to generate a human-readable `src/parser.js` with named productions.
  - Inspect the conflict message from the generator (it typically shows the conflicting productions and a small input example).
  - Open `src/rescript.grammar` around the productions mentioned and consider adding precedence, refactoring ambiguous productions, or moving tokenization logic into `src/tokens.js` if the ambiguity is lexical (for example: JSX `<` vs comparison `<`).
  - Example: the repo already disambiguates `<` using the external `jsx` tokenizer in `src/tokens.js`.

### Don'ts for the agent

- Do not commit `dist/` or `src/parser.js` changes without updating the build script — these files are generated by `npm run build` and should reflect grammar changes.
- Don't change tests to silence parsing errors — prefer fixing grammar or tokenizers so the parser accepts intended ReScript constructs.

If any sections are unclear or you want more examples (e.g., how to add a language feature or extend highlighting), tell me what to expand and I will iterate.
